import time
from Crypto.Cipher import AES

from threading import Thread
import queue    

from bluepy.btle import UUID, Peripheral, DefaultDelegate

from functools import partial

import utils
import StandardBLEGATTCharacteristics
import BLEScanner
import AmazfitBip
import Hidrate

# There are 2 processes and 2N threads, with N being the number of connected devices.

# Process 1: Main Process
#   Within the main process, there are 2N threads:
#       Each connected deveice generates 2 threads 
#           -- one for waiting for notifications (we generate this) 
#           -- one for connecting to iotc (we didn't generate this, this is auto generated by the library)

# Process 2: BLEScanner (This needs to be run in a separate process to get its own copy of bluepy-helper)
 


# define what should be done in the "main" connect loop
class ScanDelegate(DefaultDelegate):
    def __init__(self, BLEScanner):
        DefaultDelegate.__init__(self)
        self.BLEScanner = BLEScanner

    def handleDiscovery(self, dev, isNewDev, isNewData):

        if (dev.addr in self.BLEScanner.devices_to_check_for) and isNewDev:

            # print("Discovered device {0}, RSSI: {1}".format(dev.addr, dev.rssi))
            self.BLEScanner.devices_to_check_for[dev.addr]["rssi"] = dev.rssi

            if isNewDev and (dev.rssi < 0) and (self.BLEScanner.devices_to_check_for[dev.addr]["connection_status"] == "unconnected"):
                print("Found {0}".format(dev.addr))
                self.BLEScanner.to_connect_queue.put(dev.addr)

            elif (dev.rssi < 0) and (self.BLEScanner.devices_to_check_for[dev.addr]["connection_status"] == "connected"):
                print("{0} disconnected!".format(dev.addr))

if __name__ == "__main__":
    
    AMAZFITBIP_PERIPHERAL_ID = "CA:0A:FB:47:1A:95".lower()
    AMAZFITBIP_SECRET_KEY = str.encode("0123456789abcdef")

    HIDRATE_SPARK_PERIPHERAL_ID = "45:DE:A1:04:15:2D".lower()


    # This is passed to the BLEScanner, and keeps track of the rssi's and connection statuses
    device_dictionary = {
        AMAZFITBIP_PERIPHERAL_ID : {"rssi":0, "connection_status": "unconnected"},
        HIDRATE_SPARK_PERIPHERAL_ID: {"rssi":0, "connection_status": "unconnected"},
    }

    # This is used to tell the current thread how to connect to a particular device
    connection_parameters_dictionary = {
        AMAZFITBIP_PERIPHERAL_ID: partial(
            AmazfitBip.AmazfitBip, 
            SECRET_KEY = AMAZFITBIP_SECRET_KEY, 
            telemetry_connection_params = ("bf662270-03ac-4de1-b6db-2a443a6fd25a", "0ne000BC625", "5YfVVm9FxbrIobW2RD4ZpyL0gtUc7HWuPVejGXbRgJE=")
            ),
        HIDRATE_SPARK_PERIPHERAL_ID: partial(
            Hidrate.Hidrate,
            telemetry_connection_params =  ("0b352d3f-1f91-4c4a-94e8-4e3b6b7dcdf2", "0ne000BC625", "oU+XsFICYix8pWV3bFHWS5QN7UN2sMXc0HhJL0FtkRw=")
        ),
    }

    # This keeps track of all current connection objects. 
    all_current_connections_dictionary = {}

    # Start scan in new process
    blescanner = BLEScanner.BLEScanner(device_dictionary, ScanDelegate).start()
        
    # Start the current process main loop
    while True:

        # Only start connecting other devices when we've stopped scanning
        # Likely can repurpose the JoinableQueue to perform this task by making this process do a put then join
        # and make the BLEScanner thread do a get, and task done after scanning, but I think this version is much more readable
        if blescanner.process_connection_event.is_set():
            
            # Connect all the devices!
            while not blescanner.to_connect_queue.empty():
                

                # Connect to all devices that need connecting
                device_addr_to_connect = blescanner.to_connect_queue.get_nowait()
                current_connected_device = connection_parameters_dictionary[device_addr_to_connect](device_addr_to_connect)

                print("Connecting to: {0}".format(device_addr_to_connect))

                current_connected_device.connect()

                current_connected_device.startMonitoringNotifications()

                current_connected_device.initialise_device()

                all_current_connections_dictionary[device_addr_to_connect] = current_connected_device

                # Update connection status
                blescanner.devices_to_check_for[device_addr_to_connect]["connection_status"] = "connected"

                print("Connected to: {0}".format(device_addr_to_connect))

                # Notify the queue that we are done connecting:
                blescanner.to_connect_queue.task_done()
        
                # if HIDRATE_SPARK_PERIPHERAL_ID in all_current_connections_dictionary:
                #     all_current_connections_dictionary[HIDRATE_SPARK_PERIPHERAL_ID].lightUpBottle_OneShortPulseWhite()
        
        for peripheral_id, connection in list(all_current_connections_dictionary.items()):
            if not connection.connected:
                all_current_connections_dictionary.pop(peripheral_id)
                device_dictionary[peripheral_id]["connection_status"] = "unconnected"

                print("Popped {0}".format(peripheral_id))
            
